{"version":3,"file":"promiseBuffer.js","sourceRoot":"","sources":["../../../src/utils/promiseBuffer.ts"],"names":[],"mappings":"AAmBA,MAAM,UAAU,mBAAmB,CAAI,OAA6B;IAClE,MAAM,EAAE,IAAI,EAAE,WAAW,EAAE,GAAG,OAAO,CAAC;IAEtC,MAAM,MAAM,GAAyB,EAAE,CAAC,CAAC,iCAAiC;IAC1E,IAAI,UAAU,GAAG,CAAC,CAAC,CAAC,0CAA0C;IAE9D,MAAM,IAAI,GAAG,GAAG,EAAE;QAChB,uDAAuD;QACvD,uCAAuC;QACvC,IAAI,UAAU,GAAG,WAAW,IAAI,MAAM,CAAC,MAAM,EAAE,CAAC;YAC9C,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,MAAM,EAAE,GAAG,MAAM,CAAC,KAAK,EAAG,CAAC;YAEtD,UAAU,EAAE,CAAC;YAEb,QAAQ,EAAE,CAAC,IAAI,CACb,CAAC,MAAM,EAAE,EAAE;gBACT,UAAU,EAAE,CAAC;gBAEb,IAAI,EAAE,CAAC;gBAEP,OAAO,CAAC,MAAM,CAAC,CAAC;YAClB,CAAC,EACD,CAAC,MAAM,EAAE,EAAE;gBACT,UAAU,EAAE,CAAC;gBAEb,IAAI,EAAE,CAAC;gBAEP,MAAM,CAAC,MAAM,CAAC,CAAC;YACjB,CAAC,CACF,CAAC;QACJ,CAAC;IACH,CAAC,CAAC;IAEF,MAAM,GAAG,GAA4B,CAAC,eAAe,EAAE,EAAE;QACvD,IAAI,MAAM,CAAC,MAAM,GAAG,UAAU,IAAI,IAAI,EAAE,CAAC;YACvC,MAAM,IAAI,KAAK,CAAC,kBAAkB,CAAC,CAAC;QACtC,CAAC;QAED,OAAO,IAAI,OAAO,CAAI,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACxC,MAAM,CAAC,IAAI,CAAC;gBACV,QAAQ,EAAE,eAAe;gBACzB,OAAO;gBACP,MAAM;aACP,CAAC,CAAC;YACH,IAAI,EAAE,CAAC;QACT,CAAC,CAAC,CAAC;IACL,CAAC,CAAC;IAEF,OAAO;QACL,GAAG;KACJ,CAAC;AACJ,CAAC","sourcesContent":["export interface PromiseBufferOptions {\n  // total number of concurrent tasks\n  concurrency: number;\n  // total number of uncompleted tasks to accept\n  size: number;\n}\n\nexport type PromiseProducer<T> = () => PromiseLike<T>;\n\nexport interface PromiseBuffer<T> {\n  add(promiseProducer: PromiseProducer<T>): PromiseLike<T>;\n}\n\nexport interface BufferItem<T> {\n  producer: PromiseProducer<T>;\n  resolve: (value: T) => void;\n  reject: (reason?: any) => void;\n}\n\nexport function createPromiseBuffer<T>(options: PromiseBufferOptions): PromiseBuffer<T> {\n  const { size, concurrency } = options;\n\n  const buffer: Array<BufferItem<T>> = []; // pending, not-yet-started tasks\n  let inProgress = 0; // counter for tasks currently in progress\n\n  const work = () => {\n    // if there's space for a task and buffer is not empty,\n    // take one task from buffer and run it\n    if (inProgress < concurrency && buffer.length) {\n      const { producer, resolve, reject } = buffer.shift()!;\n\n      inProgress++;\n\n      producer().then(\n        (result) => {\n          inProgress--;\n\n          work();\n\n          resolve(result);\n        },\n        (reason) => {\n          inProgress--;\n\n          work();\n\n          reject(reason);\n        }\n      );\n    }\n  };\n\n  const add: PromiseBuffer<T>['add'] = (promiseProducer) => {\n    if (buffer.length + inProgress >= size) {\n      throw new Error('Task buffer full');\n    }\n\n    return new Promise<T>((resolve, reject) => {\n      buffer.push({\n        producer: promiseProducer,\n        resolve,\n        reject,\n      });\n      work();\n    });\n  };\n\n  return {\n    add,\n  };\n}\n"]}