{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../src/transports/types.ts"],"names":[],"mappings":"","sourcesContent":["import type { APIEvent, EventEvent, ExceptionEvent, LogEvent, MeasurementEvent, TraceEvent } from '../api';\nimport type { Patterns } from '../config';\nimport type { Extension } from '../extensions';\nimport type { Meta } from '../metas';\n\nimport type { TransportItemType } from './const';\n\nexport type TransportItemPayload<P = APIEvent> = P;\n\nexport type SendFn<P = APIEvent> = (items: Array<TransportItem<P>>) => void;\nexport type BeforeSendHook<P = APIEvent> = (item: TransportItem<P>) => TransportItem<P> | null;\n\nexport interface TransportItem<P = APIEvent> {\n  type: TransportItemType;\n  payload: TransportItemPayload<P>;\n  meta: Meta;\n}\n\nexport interface Transport extends Extension {\n  send(items: TransportItem | TransportItem[]): void | Promise<void>;\n\n  // returns URLs to be ignored by tracing, to not cause a feedback loop\n  getIgnoreUrls(): Patterns;\n  // returns wether the transport supports processing of a batches of items\n  isBatched(): boolean;\n}\n\nexport type BodyKey = 'exceptions' | 'logs' | 'measurements' | 'traces' | 'events';\n\nexport interface TransportBody {\n  meta: Meta;\n\n  exceptions?: ExceptionEvent[];\n  logs?: LogEvent[];\n  measurements?: MeasurementEvent[];\n  traces?: TraceEvent;\n  events?: EventEvent[];\n}\n\nexport interface Transports {\n  add: (...transports: Transport[]) => void;\n  addBeforeSendHooks: (...hooks: Array<BeforeSendHook | undefined>) => void;\n  execute: (transportItem: TransportItem) => void;\n  getBeforeSendHooks: () => BeforeSendHook[];\n  isPaused: () => boolean;\n  remove: (...transports: Transport[]) => void;\n  removeBeforeSendHooks: (...hooks: Array<BeforeSendHook | undefined>) => void;\n  transports: Transport[];\n  pause: () => void;\n  unpause: () => void;\n}\n\nexport interface BatchExecutorOptions {\n  readonly enabled?: boolean;\n  // If no new signal arrives after \"batchSendTimeout\" ms, send the payload. If set to 0, timeout is disabled\n  readonly sendTimeout?: number;\n  // Buffer \"sendLimit\" is the number of signals before sending the payload\n  readonly itemLimit?: number;\n  readonly paused?: boolean;\n}\n"]}