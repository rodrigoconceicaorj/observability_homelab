{"version":3,"file":"promiseBuffer.test.js","sourceRoot":"","sources":["../../../../../src/utils/promiseBuffer.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { createTestPromise, TestPromise } from '../testUtils';\n\nimport { createPromiseBuffer } from './promiseBuffer';\n\nasync function defer(fn: () => void) {\n  return new Promise<void>((resolve) => {\n    setTimeout(() => {\n      fn();\n      resolve();\n    }, 0);\n  });\n}\n\ndescribe('PromiseBuffer', () => {\n  it('add() new promise that resolves when task is completed', async () => {\n    const buf = createPromiseBuffer({ size: 2, concurrency: 2 });\n    expect(await buf.add(() => Promise.resolve('hi'))).toEqual('hi');\n  });\n\n  it('executes tasks concurrently, limited to concurrency setting', async () => {\n    const promises: Array<TestPromise<void>> = [];\n    const buf = createPromiseBuffer({\n      size: 10,\n      concurrency: 2,\n    });\n\n    const addTask = (id: number) => {\n      return buf.add(() => {\n        const prom = createTestPromise<void>(id);\n        promises.push(prom);\n        return prom.promise;\n      });\n    };\n\n    addTask(1);\n    addTask(2);\n    addTask(3);\n\n    // 1 & 2 have started to execute. 3d is not started\n    expect(promises).toHaveLength(2);\n    expect(promises[0]?.id).toEqual(1);\n    expect(promises[1]?.id).toEqual(2);\n\n    // resolve first two\n    promises[0]?.resolve();\n    promises[1]?.resolve();\n\n    await defer(() => {\n      // 3 has started to be executed\n      expect(promises).toHaveLength(3);\n      expect(promises[2]?.id).toEqual(3);\n      promises[2]?.resolve();\n    });\n  });\n\n  it('rejects tasks that exceed buffer size', async () => {\n    const promises: Array<TestPromise<void>> = [];\n    const buf = createPromiseBuffer({\n      size: 3,\n      concurrency: 2,\n    });\n\n    const addTask = (id: number) => {\n      return buf.add(() => {\n        const prom = createTestPromise<void>(id);\n        promises.push(prom);\n        return prom.promise;\n      });\n    };\n\n    // adding 3 tasks works, 2 of them begin executing\n    addTask(1);\n    addTask(2);\n    addTask(3);\n    expect(promises).toHaveLength(2);\n    // adding 4th task fails\n    expect(() => addTask(4)).toThrow('Task buffer full');\n\n    // finishing a task allows new tasks to be added again\n    promises[0]?.resolve();\n\n    await defer(() => {\n      addTask(4);\n    });\n  });\n});\n"]}