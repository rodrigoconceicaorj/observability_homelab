{"version":3,"file":"promiseBuffer.js","sourceRoot":"","sources":["../../../../../src/utils/promiseBuffer.ts"],"names":[],"mappings":";;AAmBA,kDAmDC;AAnDD,SAAgB,mBAAmB,CAAI,OAA6B;IAC1D,IAAA,IAAI,GAAkB,OAAO,KAAzB,EAAE,WAAW,GAAK,OAAO,YAAZ,CAAa;IAEtC,IAAM,MAAM,GAAyB,EAAE,CAAC,CAAC,iCAAiC;IAC1E,IAAI,UAAU,GAAG,CAAC,CAAC,CAAC,0CAA0C;IAE9D,IAAM,IAAI,GAAG;QACX,uDAAuD;QACvD,uCAAuC;QACvC,IAAI,UAAU,GAAG,WAAW,IAAI,MAAM,CAAC,MAAM,EAAE,CAAC;YACxC,IAAA,KAAgC,MAAM,CAAC,KAAK,EAAG,EAA7C,QAAQ,cAAA,EAAE,SAAO,aAAA,EAAE,QAAM,YAAoB,CAAC;YAEtD,UAAU,EAAE,CAAC;YAEb,QAAQ,EAAE,CAAC,IAAI,CACb,UAAC,MAAM;gBACL,UAAU,EAAE,CAAC;gBAEb,IAAI,EAAE,CAAC;gBAEP,SAAO,CAAC,MAAM,CAAC,CAAC;YAClB,CAAC,EACD,UAAC,MAAM;gBACL,UAAU,EAAE,CAAC;gBAEb,IAAI,EAAE,CAAC;gBAEP,QAAM,CAAC,MAAM,CAAC,CAAC;YACjB,CAAC,CACF,CAAC;QACJ,CAAC;IACH,CAAC,CAAC;IAEF,IAAM,GAAG,GAA4B,UAAC,eAAe;QACnD,IAAI,MAAM,CAAC,MAAM,GAAG,UAAU,IAAI,IAAI,EAAE,CAAC;YACvC,MAAM,IAAI,KAAK,CAAC,kBAAkB,CAAC,CAAC;QACtC,CAAC;QAED,OAAO,IAAI,OAAO,CAAI,UAAC,OAAO,EAAE,MAAM;YACpC,MAAM,CAAC,IAAI,CAAC;gBACV,QAAQ,EAAE,eAAe;gBACzB,OAAO,SAAA;gBACP,MAAM,QAAA;aACP,CAAC,CAAC;YACH,IAAI,EAAE,CAAC;QACT,CAAC,CAAC,CAAC;IACL,CAAC,CAAC;IAEF,OAAO;QACL,GAAG,KAAA;KACJ,CAAC;AACJ,CAAC","sourcesContent":["export interface PromiseBufferOptions {\n  // total number of concurrent tasks\n  concurrency: number;\n  // total number of uncompleted tasks to accept\n  size: number;\n}\n\nexport type PromiseProducer<T> = () => PromiseLike<T>;\n\nexport interface PromiseBuffer<T> {\n  add(promiseProducer: PromiseProducer<T>): PromiseLike<T>;\n}\n\nexport interface BufferItem<T> {\n  producer: PromiseProducer<T>;\n  resolve: (value: T) => void;\n  reject: (reason?: any) => void;\n}\n\nexport function createPromiseBuffer<T>(options: PromiseBufferOptions): PromiseBuffer<T> {\n  const { size, concurrency } = options;\n\n  const buffer: Array<BufferItem<T>> = []; // pending, not-yet-started tasks\n  let inProgress = 0; // counter for tasks currently in progress\n\n  const work = () => {\n    // if there's space for a task and buffer is not empty,\n    // take one task from buffer and run it\n    if (inProgress < concurrency && buffer.length) {\n      const { producer, resolve, reject } = buffer.shift()!;\n\n      inProgress++;\n\n      producer().then(\n        (result) => {\n          inProgress--;\n\n          work();\n\n          resolve(result);\n        },\n        (reason) => {\n          inProgress--;\n\n          work();\n\n          reject(reason);\n        }\n      );\n    }\n  };\n\n  const add: PromiseBuffer<T>['add'] = (promiseProducer) => {\n    if (buffer.length + inProgress >= size) {\n      throw new Error('Task buffer full');\n    }\n\n    return new Promise<T>((resolve, reject) => {\n      buffer.push({\n        producer: promiseProducer,\n        resolve,\n        reject,\n      });\n      work();\n    });\n  };\n\n  return {\n    add,\n  };\n}\n"]}