{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../../../src/config/types.ts"],"names":[],"mappings":"","sourcesContent":["import type { APIEvent, LogArgsSerializer, StacktraceParser } from '../api';\nimport type { Instrumentation } from '../instrumentations';\nimport type { InternalLoggerLevel } from '../internalLogger';\nimport type { Meta, MetaApp, MetaItem, MetaPage, MetaSession, MetaUser, MetaView } from '../metas';\nimport type { BatchExecutorOptions, BeforeSendHook, Transport, TransportItem } from '../transports';\nimport type { UnpatchedConsole } from '../unpatchedConsole';\nimport type { LogLevel } from '../utils';\n\ntype SamplingContext = {\n  metas: Meta;\n};\n\nexport interface Config<P = APIEvent> {\n  /**\n   * Application metadata\n   */\n  app: MetaApp;\n\n  /**\n   * Set max number and max interval for signals to be batched before sending\n   */\n  batching?: BatchExecutorOptions;\n\n  /**\n   * A flag for toggling deduplication for signals\n   */\n  dedupe: boolean;\n\n  /**\n   * The key (name) to use for the global Faro object (default: 'faro')\n   */\n  globalObjectKey: string;\n\n  /**\n   * The (custom) instrumentations to use with Faro\n   */\n  instrumentations: Instrumentation[];\n\n  /**\n   * The level of information printed to console for internal messages (default: LogLevel.ERROR)\n   */\n  internalLoggerLevel: InternalLoggerLevel;\n\n  /**\n   * Isolate Faro instance from other Faro instances on the same page. (default: false)\n   */\n  isolate: boolean;\n\n  /**\n   * Custom function to serialize log arguments\n   */\n  logArgsSerializer?: LogArgsSerializer;\n\n  /**\n   * Add custom Metas during Faro initialization\n   */\n  metas: MetaItem[];\n\n  /**\n   * Custom function used to parse stack traces\n   */\n  parseStacktrace: StacktraceParser;\n\n  /**\n   * Pause sending data (default: false)\n   */\n  paused: boolean;\n\n  /**\n   * Prevent Faro from exposing itself to the global object (default: false)\n   */\n  preventGlobalExposure: boolean;\n\n  /**\n   * The transports to use for sending beacons\n   */\n  transports: Transport[];\n\n  /**\n   * Some instrumentations might override the default console methods but Faro instance provides a\n   * way to access the unmodified console methods.\n   *\n   * faro.unpatchedConsole.log('This is a log');\n   * faro.unpatchedConsole.warn('This is a warning');\n   */\n  unpatchedConsole: UnpatchedConsole;\n\n  /**\n   * Function which invoked before pushing event to transport. Can be used to modify or filter events\n   */\n  beforeSend?: BeforeSendHook<P>;\n\n  /**\n   * Error message patterns for errors that should be ignored\n   */\n  ignoreErrors?: Patterns;\n\n  /**\n   * Path patterns for Endpoints that should be ignored form being tracked\n   */\n  ignoreUrls?: Patterns;\n\n  /**\n   * Configuration for the built in session tracker\n   */\n  sessionTracking?: {\n    /**\n     * Enable session tracking (default: true)\n     */\n    enabled?: boolean;\n    /**\n     * Wether to use sticky sessions (default: false)\n     */\n    persistent?: boolean;\n    /**\n     * Session metadata object to be used when initializing session tracking\n     */\n    session?: MetaSession;\n    /**\n     * How long is a sticky session valid for recurring users (default: 15 minutes)\n     */\n    maxSessionPersistenceTime?: number;\n    /**\n     * Called each time a session changes. This can be when a new session is created or when an existing session is updated.\n     * @param oldSession\n     * @param newSession\n     */\n    onSessionChange?: (oldSession: MetaSession | null, newSession: MetaSession) => void;\n    /**\n     * Then sampling rate for the session based sampler (default: 1). If a session is not part of a sample, no signals for this session are tracked.\n     */\n    samplingRate?: number;\n    /**\n     * Custom sampler function if custom sampling logic is needed.\n     * @param context\n     */\n    sampler?: (context: SamplingContext) => number;\n    /**\n     * Custom function to generate session id. If available Faro uses this function instead of the internal one.\n     */\n    generateSessionId?: () => string;\n  };\n\n  /**\n   * Meta object for user data\n   */\n  user?: MetaUser;\n\n  /**\n   * Meta object for view data\n   */\n  view?: MetaView;\n\n  eventDomain?: string;\n\n  /**\n   * Only resource timings for fetch and xhr requests are tracked by default. Set this to true to track all resources (default: false).\n   */\n  trackResources?: boolean;\n\n  /**\n   * Track web vitals attribution data (default: true)\n   */\n  trackWebVitalsAttribution?: boolean;\n\n  /**\n   * Configuration for the web vitals instrumentation\n   */\n  webVitalsInstrumentation?: {\n    /**\n     * Report all changes for web vitals (default: false)\n     *\n     * In most cases, you only want the callback function to be called when the metric is ready to be reported.\n     * However, it is possible to report every change (e.g. each larger layout shift as it happens)\n     * by setting reportAllChanges to true.\n     *\n     * This can be useful when debugging, but in general using reportAllChanges is not needed (or recommended)\n     * for measuring these metrics in production.\n     */\n    reportAllChanges?: boolean;\n\n    /**\n     * Track web vitals attribution data (default: true)\n     *\n     * Functionally the same as setting `trackWebVitalsAttribution` to true.\n     */\n    trackAttribution?: boolean;\n  };\n\n  /**\n   * Configuration for the console instrumentation\n   */\n  consoleInstrumentation?: {\n    /**\n     * Configure what console levels should be captured by Faro. By default the following levels\n     * are disabled: console.debug, console.trace, console.log\n     *\n     * If you want to collect all levels set captureConsoleDisabledLevels: [];\n     * If you want to disable only some levels set captureConsoleDisabledLevels: [LogLevel.DEBUG, LogLevel.TRACE];\n     */\n    disabledLevels?: LogLevel[];\n    /*\n     * By default, Faro sends an error for console.error calls. If you want to send a log instead, set this to true.\n     */\n    consoleErrorAsLog?: boolean;\n\n    /**\n     * If true, use the default Faro error serializer for console.error calls. If false, simply call toString() on the error arguments.\n     * If enabled, payloads containing serialized errors may become very large. If left disabled, some error details may be lost.\n     * (default: false)\n     */\n    serializeErrors?: boolean;\n\n    /**\n     * Custom function to serialize Error arguments\n     */\n    errorSerializer?: LogArgsSerializer;\n  };\n\n  /**\n   * Configuration for the page tracking\n   */\n  pageTracking?: {\n    /**\n     * The page meta for initial page settings\n     */\n    page?: MetaPage;\n\n    /**\n     * Allows to provide a template for the page id\n     */\n    generatePageId?: (location: Location) => string;\n  };\n\n  /**\n   * Enable or disable geolocation tracking.\n   * Geolocation tracking must be enabled in the Grafana Cloud settings first.\n   * It cannot be enabled solely on the client side.\n   * This option allows control over tracking on the client side to comply with user\n   * privacy requirements.\n   */\n  trackGeolocation?: boolean;\n\n  /**\n   * This is a preview feature.\n   * We have tested it thoroughly, but it is possible that it might not work as expected in all cases.\n   */\n  // TODO: remove preview postfix when feature is ga\n  trackUserActionsPreview?: boolean;\n\n  /**\n   * Configure your own attribute name for tracking user actions. Default is 'data-faro-user-action-name'\n   */\n  trackUserActionsDataAttributeName?: string;\n\n  /**\n   * Predicate function to exclude items from user actions.\n   * If the function returns true, the item will be excluded from user actions.\n   */\n  trackUserActionsExcludeItem?: (item: TransportItem<APIEvent>) => boolean;\n\n  /**\n   * When enabled, preserves the original Error object in the transport item for use in the beforeSend hook.\n   * The original error is automatically removed before the item is sent to the transport.\n   *\n   * This is useful for error post-processing in (uncontrolled) environments where you need to handle special cases:\n   * - Errors from third-party libraries\n   * - Errors with missing or incomplete data\n   * - Edge cases like `throw undefined` or `throw ''`\n   *\n   * With access to the original error in the beforeSend hook, you can enhance or modify the\n   * Faro exception payload to include additional context or fix missing information.\n   */\n  preserveOriginalError?: boolean;\n}\n\nexport type Patterns = Array<string | RegExp>;\n"]}